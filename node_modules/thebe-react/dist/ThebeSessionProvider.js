"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useThebeSession = exports.ThebeSessionProvider = exports.ThebeSessionContext = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importStar(require("react"));
const ThebeServerProvider_1 = require("./ThebeServerProvider");
const ThebeRenderMimeRegistryProvider_1 = require("./ThebeRenderMimeRegistryProvider");
const ThebeLoaderProvider_1 = require("./ThebeLoaderProvider");
exports.ThebeSessionContext = react_1.default.createContext(undefined);
function ThebeSessionProvider({ start = true, path, shutdownOnUnmount = false, children, }) {
    const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
    const { config, server, ready: serverReady } = (0, ThebeServerProvider_1.useThebeServer)();
    const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
    const [doStart, setDoStart] = (0, react_1.useState)(start);
    const [starting, setStarting] = (0, react_1.useState)(false);
    const [session, setSession] = (0, react_1.useState)();
    const [ready, setReady] = (0, react_1.useState)(false);
    const [error, setError] = (0, react_1.useState)();
    const [unsubscribe, setUnsubscribe] = (0, react_1.useState)();
    /// Once server connection is open, auto start a session if start prop is true
    (0, react_1.useEffect)(() => {
        if (!server || !serverReady || !doStart || starting || ready)
            return;
        startSession();
    }, [ready, doStart, starting, server, serverReady]);
    // register an event handler to monitor for session status changes
    (0, react_1.useEffect)(() => {
        if (!core || !config || !session)
            return;
        const handler = (evt, data) => {
            const subjects = [core.EventSubject.session, core.EventSubject.kernel];
            if (data.subject &&
                subjects.includes(data.subject) &&
                data.status === 'shutdown' &&
                data.id === session.id) {
                setError(`session ${session.path} - ${data.status} - ${data.message}`);
            }
        };
        setUnsubscribe(config.events.on(core.ThebeEventType.status, handler));
    }, [core, config, session]);
    const startSession = () => {
        if (!rendermime)
            throw new Error('ThebeSessionProvider requires a RenderMimeRegistryProvider');
        setStarting(true);
        server === null || server === void 0 ? void 0 : server.startNewSession(rendermime, { path }).then((sesh) => {
            setStarting(false);
            if (sesh == null) {
                server === null || server === void 0 ? void 0 : server.getKernelSpecs().then((specs) => {
                    setError(`Could not start a session - available kernels: ${Object.keys(specs.kernelspecs)}`);
                });
                return;
            }
            setSession(sesh);
            setReady(true); // not this could use the thebe event mechanism
        }, (err) => {
            setError(typeof err === 'object' ? err.message : JSON.stringify(err));
            setReady(false);
            setDoStart(false);
            setStarting(false);
        });
    };
    // shutdown session on navigate away
    (0, react_1.useEffect)(() => {
        return () => {
            if (shutdownOnUnmount) {
                unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
                setUnsubscribe(undefined);
                session === null || session === void 0 ? void 0 : session.shutdown().then(() => {
                    setReady(false);
                    setStarting(false);
                    setError(undefined);
                });
            }
        };
    }, [session]);
    return ((0, jsx_runtime_1.jsx)(exports.ThebeSessionContext.Provider, Object.assign({ value: {
            path,
            starting,
            ready,
            session,
            // eslint-disable-next-line @typescript-eslint/no-shadow
            start: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!!session && ready) {
                    yield session.restart();
                }
                else {
                    startSession();
                }
            }),
            shutdown: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (session) {
                    unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
                    setUnsubscribe(undefined);
                    yield session.shutdown();
                    setSession(undefined);
                    setReady(false);
                    setStarting(false);
                    setError(undefined);
                }
            }),
            error,
        } }, { children: children })));
}
exports.ThebeSessionProvider = ThebeSessionProvider;
function useThebeSession() {
    const sessionContext = (0, react_1.useContext)(exports.ThebeSessionContext);
    return sessionContext !== null && sessionContext !== void 0 ? sessionContext : { starting: false, ready: false };
}
exports.useThebeSession = useThebeSession;
//# sourceMappingURL=ThebeSessionProvider.js.map