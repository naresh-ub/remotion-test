"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useThebeServer = exports.useDisposeThebeServer = exports.useThebeConfig = exports.ThebeServerProvider = exports.ThebeServerContext = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importStar(require("react"));
const ThebeLoaderProvider_1 = require("./ThebeLoaderProvider");
exports.ThebeServerContext = react_1.default.createContext(undefined);
function ThebeServerProvider({ connect = true, config, options, useBinder, useJupyterLite, customConnectFn, customRepoProviders, events, children, }) {
    var _a;
    const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
    const [doConnect, setDoConnect] = (0, react_1.useState)(connect);
    const [connecting, setConnecting] = (0, react_1.useState)(false);
    const [server, setServer] = (0, react_1.useState)();
    const [ready, setReady] = (0, react_1.useState)(false);
    const [error, setError] = (0, react_1.useState)();
    const configRef = (0, react_1.useRef)();
    // create a valid configuration, either using the one supplied
    // or based on the options provided
    // once only - if options/config were to change, we'd need logic to create a new server etc..
    const thebeConfig = (0, react_1.useMemo)(() => config !== null && config !== void 0 ? config : core === null || core === void 0 ? void 0 : core.makeConfiguration(options !== null && options !== void 0 ? options : {}, events), [core, config, options]);
    // create an iniital server
    (0, react_1.useEffect)(() => {
        if (!core || !thebeConfig)
            return; // not intialized yet
        else if (thebeConfig === configRef.current && server)
            return; // config has not changed and server is already created
        const svr = new core.ThebeServer(thebeConfig);
        // register an error handler immediately
        const handler = (evt, data) => {
            const subjects = [
                core.EventSubject.server,
                core.EventSubject.session,
                core.EventSubject.kernel,
            ];
            if (data.subject && subjects.includes(data.subject)) {
                setError(`${data.status} - ${data.message}`);
            }
        };
        // TODO we need a way to unsubscribe from this that does not cause
        // error events to be missed due to rerenders
        thebeConfig.events.on(core.ThebeEventType.error, handler);
        configRef.current = thebeConfig;
        setServer(svr);
    }, [core, thebeConfig, server]);
    const connectToServer = () => {
        if (!server)
            return;
        setConnecting(true);
        if (customConnectFn)
            customConnectFn(server);
        else if (useBinder)
            server.connectToServerViaBinder(customRepoProviders);
        else if (useJupyterLite)
            server.connectToJupyterLiteServer();
        else
            server.connectToJupyterServer();
        server.ready.then(() => {
            setConnecting(false);
            setReady(true);
        }, () => {
            setConnecting(false);
            setReady(false);
        });
        return server.ready;
    };
    // Once the core is loaded, connect to a server
    // TODO: this should be an action not a side effect
    (0, react_1.useEffect)(() => {
        if (!server || !doConnect)
            return;
        // do not reconnect if already connected!
        if (server.isReady && server.userServerUrl)
            return;
        // TODO is the user server really still alive? this would be an async call to server.check
        connectToServer();
    }, [server, doConnect]);
    return ((0, jsx_runtime_1.jsx)(exports.ThebeServerContext.Provider, Object.assign({ value: {
            config: thebeConfig,
            events: events !== null && events !== void 0 ? events : thebeConfig === null || thebeConfig === void 0 ? void 0 : thebeConfig.events,
            server,
            connecting,
            ready: ((_a = server === null || server === void 0 ? void 0 : server.isReady) !== null && _a !== void 0 ? _a : false) && ready,
            connect: connectToServer,
            disconnect: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (core && thebeConfig && server) {
                    server.dispose();
                    setServer(new core.ThebeServer(thebeConfig));
                }
                setReady(false);
                setDoConnect(false);
                setConnecting(false);
                setError(undefined);
            }),
            error,
        } }, { children: children })));
}
exports.ThebeServerProvider = ThebeServerProvider;
function useThebeConfig() {
    const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
    if (serverContext === undefined) {
        throw new Error('useThebeServer must be used inside a ThebeServerProvider');
    }
    return { config: serverContext.config };
}
exports.useThebeConfig = useThebeConfig;
function useDisposeThebeServer() {
    const [disposed, setDisposed] = (0, react_1.useState)(false);
    const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
    if (serverContext === undefined) {
        throw new Error('useThebeServer must be used inside a ThebeServerProvider');
    }
    const { server, ready } = serverContext;
    (0, react_1.useEffect)(() => {
        if (!server || !ready)
            return;
        Promise.resolve().then(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield server.shutdownAllSessions();
            server.dispose();
            setDisposed(true);
        }));
    }, [ready, server]);
    return disposed;
}
exports.useDisposeThebeServer = useDisposeThebeServer;
function useThebeServer() {
    const thebe = (0, ThebeLoaderProvider_1.useThebeLoader)();
    const { core } = thebe !== null && thebe !== void 0 ? thebe : {};
    const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
    const { config, events, server, connecting, ready, connect, disconnect, error } = serverContext !== null && serverContext !== void 0 ? serverContext : {
        ready: false,
        connecting: false,
    };
    const [eventCallbacks, setEventCallbacks] = (0, react_1.useState)([]);
    const subscribe = (0, react_1.useCallback)((fn) => {
        if (!core || !config || !server)
            return;
        const callbackFn = (evt, data) => {
            const subjects = [
                core.EventSubject.server,
                core.EventSubject.session,
                core.EventSubject.kernel,
            ];
            if (data.subject && subjects.includes(data.subject))
                fn(data);
        };
        config === null || config === void 0 ? void 0 : config.events.on(core.ThebeEventType.status, callbackFn);
        setEventCallbacks([...eventCallbacks, callbackFn]);
    }, [config, server]);
    const unsubAll = (0, react_1.useCallback)(() => {
        if (!core)
            return;
        eventCallbacks.forEach((cb) => {
            config === null || config === void 0 ? void 0 : config.events.off(core.ThebeEventType.status, cb);
        });
        setEventCallbacks([]);
    }, [config, server]);
    return serverContext
        ? {
            config,
            events,
            server,
            connecting,
            ready,
            error,
            connect,
            disconnect,
            subscribe,
            unsubAll,
        }
        : { connecting: false, ready: false };
}
exports.useThebeServer = useThebeServer;
//# sourceMappingURL=ThebeServerProvider.js.map