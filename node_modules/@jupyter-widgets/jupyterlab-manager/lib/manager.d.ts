import { IClassicComm, IWidgetRegistryData, WidgetModel, WidgetView, ICallbacks } from '@jupyter-widgets/base';
import { ManagerBase, IStateOptions } from '@jupyter-widgets/base-manager';
import { IDisposable } from '@lumino/disposable';
import { ReadonlyPartialJSONValue } from '@lumino/coreutils';
import { INotebookModel } from '@jupyterlab/notebook';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { Kernel, KernelMessage, Session } from '@jupyterlab/services';
import { DocumentRegistry } from '@jupyterlab/docregistry';
import { ISignal, Signal } from '@lumino/signaling';
/**
 * The mime type for a widget view.
 */
export declare const WIDGET_VIEW_MIMETYPE = "application/vnd.jupyter.widget-view+json";
/**
 * The mime type for widget state data.
 */
export declare const WIDGET_STATE_MIMETYPE = "application/vnd.jupyter.widget-state+json";
/**
 * A widget manager that returns Lumino widgets.
 */
export declare abstract class LabWidgetManager extends ManagerBase implements IDisposable {
    constructor(rendermime: IRenderMimeRegistry);
    /**
     * Default callback handler to emit unhandled kernel messages.
     */
    callbacks(view?: WidgetView): ICallbacks;
    /**
     * Register a new kernel
     */
    protected _handleKernelChanged({ oldValue, newValue, }: Session.ISessionConnection.IKernelChangedArgs): void;
    /**
     * Disconnect the widget manager from the kernel, setting each model's comm
     * as dead.
     */
    disconnect(): void;
    protected _loadFromKernel(): Promise<void>;
    /**
     * Create a comm.
     */
    _create_comm(target_name: string, model_id: string, data?: any, metadata?: any, buffers?: ArrayBuffer[] | ArrayBufferView[]): Promise<IClassicComm>;
    /**
     * Get the currently-registered comms.
     */
    _get_comm_info(): Promise<any>;
    /**
     * Get whether the manager is disposed.
     *
     * #### Notes
     * This is a read-only property.
     */
    get isDisposed(): boolean;
    /**
     * Dispose the resources held by the manager.
     */
    dispose(): void;
    /**
     * Resolve a URL relative to the current notebook location.
     */
    resolveUrl(url: string): Promise<string>;
    /**
     * Load a class and return a promise to the loaded object.
     */
    protected loadClass(className: string, moduleName: string, moduleVersion: string): Promise<typeof WidgetModel | typeof WidgetView>;
    abstract get kernel(): Kernel.IKernelConnection | null;
    get rendermime(): IRenderMimeRegistry;
    /**
     * A signal emitted when state is restored to the widget manager.
     *
     * #### Notes
     * This indicates that previously-unavailable widget models might be available now.
     */
    get restored(): ISignal<this, void>;
    /**
     * Whether the state has been restored yet or not.
     */
    get restoredStatus(): boolean;
    /**
     * A signal emitted for unhandled iopub kernel messages.
     *
     */
    get onUnhandledIOPubMessage(): ISignal<this, KernelMessage.IIOPubMessage>;
    register(data: IWidgetRegistryData): void;
    /**
     * Register a widget model.
     */
    register_model(model_id: string, modelPromise: Promise<WidgetModel>): void;
    /**
     * Close all widgets and empty the widget state.
     * @return Promise that resolves when the widget state is cleared.
     */
    clear_state(): Promise<void>;
    /**
     * Synchronously get the state of the live widgets in the widget manager.
     *
     * This includes all of the live widget models, and follows the format given in
     * the @jupyter-widgets/schema package.
     *
     * @param options - The options for what state to return.
     * @returns A state dictionary
     */
    get_state_sync(options?: IStateOptions): ReadonlyPartialJSONValue;
    protected _handleCommOpen: (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => Promise<void>;
    protected _restored: Signal<this, void>;
    protected _restoredStatus: boolean;
    protected _kernelRestoreInProgress: boolean;
    private _isDisposed;
    private _registry;
    private _rendermime;
    private _commRegistration;
    private _modelsSync;
    private _onUnhandledIOPubMessage;
}
/**
 * A widget manager that returns Lumino widgets.
 */
export declare class KernelWidgetManager extends LabWidgetManager {
    constructor(kernel: Kernel.IKernelConnection, rendermime: IRenderMimeRegistry);
    _handleKernelConnectionStatusChange(status: Kernel.ConnectionStatus): void;
    _handleKernelStatusChange(status: Kernel.Status): void;
    /**
     * Restore widgets from kernel and saved state.
     */
    restoreWidgets(): Promise<void>;
    /**
     * Dispose the resources held by the manager.
     */
    dispose(): void;
    get kernel(): Kernel.IKernelConnection;
    private _kernel;
}
/**
 * A widget manager that returns phosphor widgets.
 */
export declare class WidgetManager extends LabWidgetManager {
    constructor(context: DocumentRegistry.IContext<INotebookModel>, rendermime: IRenderMimeRegistry, settings: WidgetManager.Settings);
    /**
     * Save the widget state to the context model.
     */
    private _saveState;
    _handleKernelConnectionStatusChange(status: Kernel.ConnectionStatus): void;
    _handleKernelStatusChange(status: Kernel.Status): void;
    /**
     * Restore widgets from kernel and saved state.
     */
    restoreWidgets(notebook: INotebookModel, { loadKernel, loadNotebook }?: {
        loadKernel: boolean;
        loadNotebook: boolean;
    }): Promise<void>;
    /**
     * Load widget state from notebook metadata
     */
    _loadFromNotebook(notebook: INotebookModel): Promise<void>;
    /**
     * Dispose the resources held by the manager.
     */
    dispose(): void;
    /**
     * Resolve a URL relative to the current notebook location.
     */
    resolveUrl(url: string): Promise<string>;
    get context(): DocumentRegistry.IContext<INotebookModel>;
    get kernel(): Kernel.IKernelConnection | null;
    /**
     * Register a widget model.
     */
    register_model(model_id: string, modelPromise: Promise<WidgetModel>): void;
    /**
     * Close all widgets and empty the widget state.
     * @return Promise that resolves when the widget state is cleared.
     */
    clear_state(): Promise<void>;
    /**
     * Set the dirty state of the notebook model if applicable.
     *
     * TODO: perhaps should also set dirty when any model changes any data
     */
    setDirty(): void;
    private _context;
    private _settings;
}
export declare namespace WidgetManager {
    type Settings = {
        saveState: boolean;
    };
}
//# sourceMappingURL=manager.d.ts.map