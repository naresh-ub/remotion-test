import { PathExt } from '@jupyterlab/coreutils';
import { ArrayExt } from '@lumino/algorithm';
import { UUID } from '@lumino/coreutils';
/**
 * A class to handle requests to /api/sessions
 */
export class Sessions {
    /**
     * Construct a new Sessions.
     *
     * @param options The instantiation options for a Sessions.
     */
    constructor(options) {
        // TODO: offload to a database
        this._sessions = [];
        this._kernels = options.kernels;
    }
    /**
     * Get a session by id.
     *
     * @param id The id of the session.
     */
    async get(id) {
        const session = this._sessions.find((s) => s.id === id);
        if (!session) {
            throw Error(`Session ${id} not found`);
        }
        return session;
    }
    /**
     * List the running sessions
     */
    async list() {
        return this._sessions;
    }
    /**
     * Path an existing session.
     * This can be used to rename a session.
     *
     * - path updates session to track renamed paths
     * - kernel.name starts a new kernel with a given kernelspec
     *
     * @param options The options to patch the session.
     */
    async patch(options) {
        const { id, path, name, kernel } = options;
        const index = this._sessions.findIndex((s) => s.id === id);
        const session = this._sessions[index];
        if (!session) {
            throw Error(`Session ${id} not found`);
        }
        const patched = {
            ...session,
            path: path !== null && path !== void 0 ? path : session.path,
            name: name !== null && name !== void 0 ? name : session.name,
        };
        if (kernel) {
            // Kernel id takes precedence over name.
            if (kernel.id) {
                const session = this._sessions.find((session) => { var _a; return ((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) === (kernel === null || kernel === void 0 ? void 0 : kernel.id); });
                if (session) {
                    patched.kernel = session.kernel;
                }
            }
            else if (kernel.name) {
                const newKernel = await this._kernels.startNew({
                    id: UUID.uuid4(),
                    name: kernel.name,
                    location: PathExt.dirname(patched.path),
                });
                if (newKernel) {
                    patched.kernel = newKernel;
                }
                // clean up the session on kernel shutdown
                void this._handleKernelShutdown({
                    kernelId: newKernel.id,
                    sessionId: session.id,
                });
            }
        }
        this._sessions[index] = patched;
        return patched;
    }
    /**
     * Start a new session
     * TODO: read path and name
     *
     * @param options The options to start a new session.
     */
    async startNew(options) {
        var _a, _b, _c, _d;
        const { path, name } = options;
        const running = this._sessions.find((s) => s.name === name);
        if (running) {
            return running;
        }
        const kernelName = (_b = (_a = options.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';
        const id = (_c = options.id) !== null && _c !== void 0 ? _c : UUID.uuid4();
        const nameOrPath = (_d = options.name) !== null && _d !== void 0 ? _d : options.path;
        const dirname = PathExt.dirname(options.name) || PathExt.dirname(options.path);
        const hasDrive = nameOrPath.includes(':');
        const driveName = hasDrive ? nameOrPath.split(':')[0] : '';
        // add drive name if missing (top level directory)
        const location = dirname.includes(driveName) ? dirname : `${driveName}:${dirname}`;
        const kernel = await this._kernels.startNew({
            id,
            name: kernelName,
            location,
        });
        const session = {
            id,
            path,
            name: name !== null && name !== void 0 ? name : path,
            type: 'notebook',
            kernel: {
                id: kernel.id,
                name: kernel.name,
            },
        };
        this._sessions.push(session);
        // clean up the session on kernel shutdown
        void this._handleKernelShutdown({ kernelId: id, sessionId: session.id });
        return session;
    }
    /**
     * Shut down a session.
     *
     * @param id The id of the session to shut down.
     */
    async shutdown(id) {
        var _a;
        const session = this._sessions.find((s) => s.id === id);
        if (!session) {
            throw Error(`Session ${id} not found`);
        }
        const kernelId = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id;
        if (kernelId) {
            await this._kernels.shutdown(kernelId);
        }
        ArrayExt.removeFirstOf(this._sessions, session);
    }
    /**
     * Handle kernel shutdown
     */
    async _handleKernelShutdown({ kernelId, sessionId, }) {
        const runningKernel = await this._kernels.get(kernelId);
        if (runningKernel) {
            runningKernel.disposed.connect(() => {
                this.shutdown(sessionId);
            });
        }
    }
}
//# sourceMappingURL=sessions.js.map