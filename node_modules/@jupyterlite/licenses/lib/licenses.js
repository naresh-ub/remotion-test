// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { URLExt, PageConfig } from '@jupyterlab/coreutils';
import { THIRD_PARTY_LICENSES, } from './tokens';
/**
 * An empty bundle.
 */
const EMPTY_BUNDLE = Object.freeze({ packages: [] });
/**
 * A JupyterLite implementation of the jupyterlab_server licenses route
 */
export class Licenses {
    /**
     * A GET handler for the licenses
     */
    async get() {
        return {
            bundles: {
                ...(await this._getFederated()),
                [this.appName]: await this._getAppLicenses(),
            },
        };
    }
    /**
     * Get the app name (or default).
     */
    get appName() {
        return PageConfig.getOption('appName') || 'JupyterLite';
    }
    /**
     * Get the well-known URL of the app licenses.
     */
    get appLicensesUrl() {
        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);
    }
    /**
     * Get the lab extension base url.
     */
    get labExtensionsUrl() {
        return PageConfig.getOption('fullLabextensionsUrl');
    }
    /**
     * Resolve the licenses for the app distribution itself, or the empty bundle.
     */
    async _getAppLicenses() {
        let bundle = EMPTY_BUNDLE;
        try {
            const response = await fetch(this.appLicensesUrl);
            bundle = response.json();
        }
        catch (err) {
            console.warn('Could not resolve licenses for', this.appName);
        }
        return bundle;
    }
    /**
     * Resolve the licenses for all federated extensions.
     */
    async _getFederated() {
        const bundles = {};
        let federated;
        try {
            federated = JSON.parse(PageConfig.getOption('federated_extensions'));
        }
        catch {
            return bundles;
        }
        const promises = [];
        for (const ext of federated) {
            promises.push(this._getOneFederated(ext, bundles));
        }
        try {
            await Promise.all(promises);
        }
        catch (err) {
            console.warn('Error resolving licenses', err);
        }
        return bundles;
    }
    /**
     * Update the bundles with the extension's licenses, or the empty bundle.
     */
    async _getOneFederated(ext, bundles) {
        try {
            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);
            const response = await fetch(url);
            bundles[ext.name] = await response.json();
        }
        catch {
            console.warn('Could not resolve licenses for', ext);
            bundles[ext.name] = EMPTY_BUNDLE;
        }
    }
}
//# sourceMappingURL=licenses.js.map