import { ObservableMap } from '@jupyterlab/observables';
import { KernelAPI } from '@jupyterlab/services';
import { deserialize, serialize } from '@jupyterlab/services/lib/kernel/serialize';
import { supportedKernelWebSocketProtocols } from '@jupyterlab/services/lib/kernel/messages';
import { UUID } from '@lumino/coreutils';
import { Server as WebSocketServer } from 'mock-socket';
import { Mutex } from 'async-mutex';
import { PageConfig, URLExt } from '@jupyterlab/coreutils';
/**
 * Use the default kernel wire protocol.
 */
const KERNEL_WEBSOCKET_PROTOCOL = supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg;
/**
 * A class to handle requests to /api/kernels
 */
export class Kernels {
    /**
     * Construct a new Kernels
     *
     * @param options The instantiation options
     */
    constructor(options) {
        this._kernels = new ObservableMap();
        this._clients = new ObservableMap();
        this._kernelClients = new ObservableMap();
        const { kernelspecs } = options;
        this._kernelspecs = kernelspecs;
    }
    /**
     * Start a new kernel.
     *
     * @param options The kernel start options.
     */
    async startNew(options) {
        const { id, name, location } = options;
        const factory = this._kernelspecs.factories.get(name);
        // bail if there is no factory associated with the requested kernel
        if (!factory) {
            return { id, name };
        }
        // create a synchronization mechanism to allow only one message
        // to be processed at a time
        const mutex = new Mutex();
        // hook a new client to a kernel
        const hook = (kernelId, clientId, socket) => {
            var _a;
            const kernel = this._kernels.get(kernelId);
            if (!kernel) {
                throw Error(`No kernel ${kernelId}`);
            }
            this._clients.set(clientId, socket);
            (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.add(clientId);
            const processMsg = async (msg) => {
                await mutex.runExclusive(async () => {
                    await kernel.ready;
                    await kernel.handleMessage(msg);
                });
            };
            socket.on('message', async (message) => {
                let msg;
                if (message instanceof ArrayBuffer) {
                    message = new Uint8Array(message).buffer;
                    msg = deserialize(message, KERNEL_WEBSOCKET_PROTOCOL);
                }
                else if (typeof message === 'string') {
                    const encoder = new TextEncoder();
                    const encodedData = encoder.encode(message);
                    msg = deserialize(encodedData.buffer, KERNEL_WEBSOCKET_PROTOCOL);
                }
                else {
                    return;
                }
                // TODO Find a better solution for this?
                // input-reply is asynchronous, must not be processed like other messages
                if (msg.header.msg_type === 'input_reply') {
                    kernel.handleMessage(msg);
                }
                else {
                    void processMsg(msg);
                }
            });
            const removeClient = () => {
                var _a;
                this._clients.delete(clientId);
                (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);
            };
            kernel.disposed.connect(removeClient);
            // TODO: check whether this is called
            // https://github.com/thoov/mock-socket/issues/298
            // https://github.com/jupyterlab/jupyterlab/blob/6bc884a7a8ed73c615ce72ba097bdb790482b5bf/packages/services/src/kernel/default.ts#L1245
            socket.onclose = removeClient;
        };
        // ensure kernel id
        const kernelId = id !== null && id !== void 0 ? id : UUID.uuid4();
        // There is one server per kernel which handles multiple clients
        const kernelUrl = URLExt.join(Kernels.WS_BASE_URL, KernelAPI.KERNEL_SERVICE_URL, encodeURIComponent(kernelId), 'channels');
        const runningKernel = this._kernels.get(kernelId);
        if (runningKernel) {
            return {
                id: runningKernel.id,
                name: runningKernel.name,
            };
        }
        // start the kernel
        const sendMessage = (msg) => {
            const clientId = msg.header.session;
            const socket = this._clients.get(clientId);
            if (!socket) {
                console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);
                return;
            }
            const message = serialize(msg, KERNEL_WEBSOCKET_PROTOCOL);
            // process iopub messages
            if (msg.channel === 'iopub') {
                const clients = this._kernelClients.get(kernelId);
                clients === null || clients === void 0 ? void 0 : clients.forEach((id) => {
                    var _a;
                    (_a = this._clients.get(id)) === null || _a === void 0 ? void 0 : _a.send(message);
                });
                return;
            }
            socket.send(message);
        };
        const kernel = await factory({
            id: kernelId,
            sendMessage,
            name,
            location,
        });
        this._kernels.set(kernelId, kernel);
        this._kernelClients.set(kernelId, new Set());
        // create the websocket server for the kernel
        const wsServer = new WebSocketServer(kernelUrl, {
            mock: false,
            selectProtocol: () => KERNEL_WEBSOCKET_PROTOCOL,
        });
        wsServer.on('connection', (socket) => {
            var _a;
            const url = new URL(socket.url);
            const clientId = (_a = url.searchParams.get('session_id')) !== null && _a !== void 0 ? _a : '';
            hook(kernelId, clientId, socket);
        });
        // clean up closed connection
        wsServer.on('close', () => {
            this._clients.keys().forEach((clientId) => {
                var _a;
                const socket = this._clients.get(clientId);
                if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.CLOSED) {
                    this._clients.delete(clientId);
                    (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);
                }
            });
        });
        // cleanup on kernel shutdown
        kernel.disposed.connect(() => {
            wsServer.close();
            this._kernels.delete(kernelId);
            this._kernelClients.delete(kernelId);
        });
        return {
            id: kernel.id,
            name: kernel.name,
        };
    }
    /**
     * Restart a kernel.
     *
     * @param kernelId The kernel id.
     */
    async restart(kernelId) {
        const kernel = this._kernels.get(kernelId);
        if (!kernel) {
            throw Error(`Kernel ${kernelId} does not exist`);
        }
        const { id, name, location } = kernel;
        kernel.dispose();
        return this.startNew({ id, name, location });
    }
    /**
     * List the running kernels.
     */
    async list() {
        return [...this._kernels.values()].map((kernel) => ({
            id: kernel.id,
            name: kernel.name,
        }));
    }
    /**
     * Shut down a kernel.
     *
     * @param id The kernel id.
     */
    async shutdown(id) {
        var _a;
        (_a = this._kernels.delete(id)) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    /**
     * Get a kernel by id
     */
    async get(id) {
        return this._kernels.get(id);
    }
}
/**
 * A namespace for Kernels statics.
 */
(function (Kernels) {
    /**
     * The base url for the Kernels manager
     */
    Kernels.WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');
})(Kernels || (Kernels = {}));
//# sourceMappingURL=kernels.js.map