import { PathExt } from '@jupyterlab/coreutils';
import { BLOCK_SIZE } from './drivefs';
import { DIR_MODE, FILE_MODE } from './emscripten';
/**
 * Class for processing a drive request from the DriveFS.
 */
export class DriveContentsProcessor {
    constructor(options) {
        this.contentsManager = options.contentsManager;
    }
    async processDriveRequest(request) {
        switch (request.method) {
            case 'readdir':
                return this.readdir(request);
            case 'rmdir':
                return this.rmdir(request);
            case 'rename':
                return this.rename(request);
            case 'getmode':
                return this.getmode(request);
            case 'lookup':
                return this.lookup(request);
            case 'mknod':
                return this.mknod(request);
            case 'getattr':
                return this.getattr(request);
            case 'get':
                return this.get(request);
            case 'put':
                return this.put(request);
        }
        throw `Drive request ${request.method} does not exist.`;
    }
    async readdir(request) {
        const model = await this.contentsManager.get(request.path, { content: true });
        let response = [];
        if (model.type === 'directory' && model.content) {
            response = model.content.map((subcontent) => subcontent.name);
        }
        return response;
    }
    async rmdir(request) {
        await this.contentsManager.delete(request.path);
        return null;
    }
    async rename(request) {
        await this.contentsManager.rename(request.path, request.data.newPath);
        return null;
    }
    async getmode(request) {
        const model = await this.contentsManager.get(request.path);
        let response;
        if (model.type === 'directory') {
            response = DIR_MODE;
        }
        else {
            response = FILE_MODE;
        }
        return response;
    }
    async lookup(request) {
        let response;
        try {
            const model = await this.contentsManager.get(request.path);
            response = {
                ok: true,
                mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,
            };
        }
        catch (e) {
            response = { ok: false };
        }
        return response;
    }
    async mknod(request) {
        const model = await this.contentsManager.newUntitled({
            path: PathExt.dirname(request.path),
            type: request.data.mode === DIR_MODE ? 'directory' : 'file',
            ext: PathExt.extname(request.path),
        });
        await this.contentsManager.rename(model.path, request.path);
        return null;
    }
    async getattr(request) {
        const model = await this.contentsManager.get(request.path);
        // create a default date for drives that send incomplete information
        // for nested foldes and files
        const defaultDate = new Date(0).toISOString();
        return {
            dev: 1,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: 0,
            size: model.size || 0,
            blksize: BLOCK_SIZE,
            blocks: Math.ceil(model.size || 0 / BLOCK_SIZE),
            atime: model.last_modified || defaultDate,
            mtime: model.last_modified || defaultDate,
            ctime: model.created || defaultDate,
            timestamp: 0,
        };
    }
    async get(request) {
        const model = await this.contentsManager.get(request.path, { content: true });
        let response;
        if (model.type !== 'directory') {
            response = {
                content: model.format === 'json' ? JSON.stringify(model.content) : model.content,
                format: model.format,
            };
        }
        return response;
    }
    async put(request) {
        await this.contentsManager.save(request.path, {
            content: request.data.format === 'json'
                ? JSON.parse(request.data.data)
                : request.data.data,
            type: 'file',
            format: request.data.format,
        });
        return null;
    }
}
//# sourceMappingURL=drivecontents.js.map