// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { DIR_MODE, SEEK_CUR, SEEK_END, instanceOfStream, } from './emscripten';
export const DRIVE_SEPARATOR = ':';
export const DRIVE_API_PATH = '/api/drive.v1';
export const BLOCK_SIZE = 4096;
const encoder = new TextEncoder();
const decoder = new TextDecoder('utf-8');
// Mapping flag -> do we need to overwrite the file upon closing it
const flagNeedsWrite = {
    0 /*O_RDONLY*/: false,
    1 /*O_WRONLY*/: true,
    2 /*O_RDWR*/: true,
    64 /*O_CREAT*/: true,
    65 /*O_WRONLY|O_CREAT*/: true,
    66 /*O_RDWR|O_CREAT*/: true,
    129 /*O_WRONLY|O_EXCL*/: true,
    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,
    514 /*O_RDWR|O_TRUNC*/: true,
    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,
    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,
    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,
    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,
    1024 /*O_APPEND*/: true,
    1025 /*O_WRONLY|O_APPEND*/: true,
    1026 /*O_RDWR|O_APPEND*/: true,
    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,
    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,
    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,
    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,
    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,
    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,
    4096 /*O_RDONLY|O_DSYNC*/: true,
    4098 /*O_RDWR|O_DSYNC*/: true,
};
export class DriveFSEmscriptenStreamOps {
    constructor(fs) {
        this.fs = fs;
    }
    open(stream) {
        const path = this.fs.realPath(stream.node);
        if (this.fs.FS.isFile(stream.node.mode)) {
            stream.file = this.fs.API.get(path);
        }
    }
    close(stream) {
        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {
            return;
        }
        const path = this.fs.realPath(stream.node);
        const flags = stream.flags;
        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;
        parsedFlags &= 0x1fff;
        let needsWrite = true;
        if (parsedFlags in flagNeedsWrite) {
            needsWrite = flagNeedsWrite[parsedFlags];
        }
        if (needsWrite) {
            this.fs.API.put(path, stream.file);
        }
        stream.file = undefined;
    }
    read(stream, buffer, offset, length, position) {
        if (length <= 0 ||
            stream.file === undefined ||
            position >= (stream.file.data.length || 0)) {
            return 0;
        }
        const size = Math.min(stream.file.data.length - position, length);
        buffer.set(stream.file.data.subarray(position, position + size), offset);
        return size;
    }
    write(stream, buffer, offset, length, position) {
        var _a;
        if (length <= 0 || stream.file === undefined) {
            return 0;
        }
        stream.node.timestamp = Date.now();
        if (position + length > (((_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) || 0)) {
            const oldData = stream.file.data ? stream.file.data : new Uint8Array();
            stream.file.data = new Uint8Array(position + length);
            stream.file.data.set(oldData);
        }
        stream.file.data.set(buffer.subarray(offset, offset + length), position);
        return length;
    }
    llseek(stream, offset, whence) {
        let position = offset;
        if (whence === SEEK_CUR) {
            position += stream.position;
        }
        else if (whence === SEEK_END) {
            if (this.fs.FS.isFile(stream.node.mode)) {
                if (stream.file !== undefined) {
                    position += stream.file.data.length;
                }
                else {
                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);
                }
            }
        }
        if (position < 0) {
            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);
        }
        return position;
    }
}
export class DriveFSEmscriptenNodeOps {
    constructor(fs) {
        this.fs = fs;
    }
    node(nodeOrStream) {
        if (instanceOfStream(nodeOrStream)) {
            return nodeOrStream.node;
        }
        return nodeOrStream;
    }
    getattr(value) {
        const node = this.node(value);
        return {
            ...this.fs.API.getattr(this.fs.realPath(node)),
            mode: node.mode,
            ino: node.id,
        };
    }
    setattr(value, attr) {
        const node = this.node(value);
        for (const [key, value] of Object.entries(attr)) {
            switch (key) {
                case 'mode':
                    node.mode = value;
                    break;
                case 'timestamp':
                    node.timestamp = value;
                    break;
                case 'size': {
                    const size = value;
                    const path = this.fs.realPath(node);
                    if (this.fs.FS.isFile(node.mode) && size >= 0) {
                        const file = this.fs.API.get(path);
                        const oldData = file.data ? file.data : new Uint8Array();
                        if (size !== oldData.length) {
                            if (size < oldData.length) {
                                file.data = file.data.slice(0, size);
                            }
                            else {
                                file.data = new Uint8Array(size);
                                file.data.set(oldData);
                            }
                            this.fs.API.put(path, file);
                        }
                    }
                    else {
                        console.warn('setattr size of', size, 'on', node, 'not yet implemented');
                    }
                    break;
                }
                default:
                    console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');
                    break;
            }
        }
    }
    lookup(parent, name) {
        const node = this.node(parent);
        const path = this.fs.PATH.join2(this.fs.realPath(node), name);
        const result = this.fs.API.lookup(path);
        if (!result.ok) {
            throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];
        }
        return this.fs.createNode(node, name, result.mode, 0);
    }
    mknod(parent, name, mode, dev) {
        const node = this.node(parent);
        const path = this.fs.PATH.join2(this.fs.realPath(node), name);
        this.fs.API.mknod(path, mode);
        return this.fs.createNode(node, name, mode, dev);
    }
    rename(value, newDir, newName) {
        const oldNode = this.node(value);
        const newDirNode = this.node(newDir);
        this.fs.API.rename(oldNode.parent
            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)
            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDirNode), newName));
        // Updating the in-memory node
        oldNode.name = newName;
        oldNode.parent = newDirNode;
    }
    unlink(parent, name) {
        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));
    }
    rmdir(parent, name) {
        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));
    }
    readdir(value) {
        return this.fs.API.readdir(this.fs.realPath(this.node(value)));
    }
    symlink(parent, newName, oldPath) {
        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);
    }
    readlink(node) {
        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);
    }
}
/**
 * ContentsAPI base class
 */
export class ContentsAPI {
    constructor(driveName, mountpoint, FS, ERRNO_CODES) {
        this._driveName = driveName;
        this._mountpoint = mountpoint;
        this.FS = FS;
        this.ERRNO_CODES = ERRNO_CODES;
    }
    lookup(path) {
        return this.request({ method: 'lookup', path: this.normalizePath(path) });
    }
    getmode(path) {
        return this.request({ method: 'getmode', path: this.normalizePath(path) });
    }
    mknod(path, mode) {
        return this.request({
            method: 'mknod',
            path: this.normalizePath(path),
            data: { mode },
        });
    }
    rename(oldPath, newPath) {
        return this.request({
            method: 'rename',
            path: this.normalizePath(oldPath),
            data: { newPath: this.normalizePath(newPath) },
        });
    }
    readdir(path) {
        const dirlist = this.request({
            method: 'readdir',
            path: this.normalizePath(path),
        });
        dirlist.push('.');
        dirlist.push('..');
        return dirlist;
    }
    rmdir(path) {
        return this.request({ method: 'rmdir', path: this.normalizePath(path) });
    }
    get(path) {
        const response = this.request({
            method: 'get',
            path: this.normalizePath(path),
        });
        if (!response) {
            throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);
        }
        const serializedContent = response.content;
        const format = response.format;
        switch (format) {
            case 'json':
            case 'text':
                return {
                    data: encoder.encode(serializedContent),
                    format,
                };
            case 'base64': {
                const binString = atob(serializedContent);
                const len = binString.length;
                const data = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    data[i] = binString.charCodeAt(i);
                }
                return {
                    data,
                    format,
                };
            }
            default:
                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);
        }
    }
    put(path, value) {
        switch (value.format) {
            case 'json':
            case 'text':
                return this.request({
                    method: 'put',
                    path: this.normalizePath(path),
                    data: {
                        format: value.format,
                        data: decoder.decode(value.data),
                    },
                });
            case 'base64': {
                let binary = '';
                for (let i = 0; i < value.data.byteLength; i++) {
                    binary += String.fromCharCode(value.data[i]);
                }
                return this.request({
                    method: 'put',
                    path: this.normalizePath(path),
                    data: {
                        format: value.format,
                        data: btoa(binary),
                    },
                });
            }
        }
    }
    getattr(path) {
        const stats = this.request({
            method: 'getattr',
            path: this.normalizePath(path),
        });
        // Turn datetimes into proper objects
        if (stats.atime) {
            stats.atime = new Date(stats.atime);
        }
        if (stats.mtime) {
            stats.mtime = new Date(stats.mtime);
        }
        if (stats.ctime) {
            stats.ctime = new Date(stats.ctime);
        }
        // ensure a non-undefined size (0 isn't great, though)
        stats.size = stats.size || 0;
        return stats;
    }
    /**
     * Normalize a Path by making it compliant for the content manager
     *
     * @param path: the path relatively to the Emscripten drive
     */
    normalizePath(path) {
        // Remove mountpoint prefix
        if (path.startsWith(this._mountpoint)) {
            path = path.slice(this._mountpoint.length);
        }
        // Add JupyterLab drive name
        if (this._driveName) {
            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;
        }
        return path;
    }
}
/**
 * An Emscripten-compatible synchronous Contents API using the service worker.
 */
export class ServiceWorkerContentsAPI extends ContentsAPI {
    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {
        super(driveName, mountpoint, FS, ERRNO_CODES);
        this._baseUrl = baseUrl;
    }
    request(data) {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', encodeURI(this.endpoint), false);
        try {
            xhr.send(JSON.stringify(data));
        }
        catch (e) {
            console.error(e);
        }
        if (xhr.status >= 400) {
            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);
        }
        return JSON.parse(xhr.responseText);
    }
    /**
     * Get the api/drive endpoint
     */
    get endpoint() {
        return `${this._baseUrl}api/drive`;
    }
}
export class DriveFS {
    constructor(options) {
        this.FS = options.FS;
        this.PATH = options.PATH;
        this.ERRNO_CODES = options.ERRNO_CODES;
        this.API = this.createAPI(options);
        this.driveName = options.driveName;
        this.node_ops = new DriveFSEmscriptenNodeOps(this);
        this.stream_ops = new DriveFSEmscriptenStreamOps(this);
    }
    /**
     * Create the ContentsAPI.
     *
     * This is supposed to be overwritten if needed.
     */
    createAPI(options) {
        return new ServiceWorkerContentsAPI(options.baseUrl, options.driveName, options.mountpoint, options.FS, options.ERRNO_CODES);
    }
    mount(mount) {
        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);
    }
    createNode(parent, name, mode, dev) {
        const FS = this.FS;
        if (!FS.isDir(mode) && !FS.isFile(mode)) {
            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);
        }
        const node = FS.createNode(parent, name, mode, dev);
        node.node_ops = this.node_ops;
        node.stream_ops = this.stream_ops;
        return node;
    }
    getMode(path) {
        return this.API.getmode(path);
    }
    realPath(node) {
        const parts = [];
        let currentNode = node;
        parts.push(currentNode.name);
        while (currentNode.parent !== currentNode) {
            currentNode = currentNode.parent;
            parts.push(currentNode.name);
        }
        parts.reverse();
        return this.PATH.join.apply(null, parts);
    }
}
//# sourceMappingURL=drivefs.js.map