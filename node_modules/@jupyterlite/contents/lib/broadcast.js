// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { DRIVE_API_PATH } from './drivefs';
import { DriveContentsProcessor } from './drivecontents';
/** A broadcaster for the ServiceWorker */
export class BroadcastChannelWrapper {
    constructor(options) {
        this.isDisposed = false;
        /** Handle a message received on the BroadcastChannel */
        this._onMessage = async (event) => {
            if (!this._channel) {
                return;
            }
            const request = event.data;
            const receiver = request === null || request === void 0 ? void 0 : request.receiver;
            if (receiver !== 'broadcast.ts') {
                // Message is not meant for us
                return;
            }
            const response = await this._driveContentsProcessor.processDriveRequest(request);
            this._channel.postMessage(response);
        };
        this._channel = null;
        this._enabled = false;
        this._contents = options.contents;
        this._driveContentsProcessor = new DriveContentsProcessor({
            contentsManager: this._contents,
        });
    }
    get enabled() {
        return this._enabled;
    }
    enable() {
        if (this._channel) {
            console.warn('BroadcastChannel already created and enabled');
            return;
        }
        this._channel = new BroadcastChannel(DRIVE_API_PATH);
        this._channel.addEventListener('message', this._onMessage);
        this._enabled = true;
    }
    disable() {
        if (this._channel) {
            this._channel.removeEventListener('message', this._onMessage);
            this._channel = null;
        }
        this._enabled = false;
    }
    /** Clean up the broadcaster. */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.disable();
        this.isDisposed = true;
    }
}
//# sourceMappingURL=broadcast.js.map