import { PageConfig } from '@jupyterlab/coreutils';
import mime from 'mime';
import { Token } from '@lumino/coreutils';
/**
 * The token for the settings service.
 */
export const IContents = new Token('@jupyterlite/contents:IContents');
/**
 * Commonly-used mimetypes
 */
export var MIME;
(function (MIME) {
    MIME.JSON = 'application/json';
    MIME.PLAIN_TEXT = 'text/plain';
    MIME.OCTET_STREAM = 'octet/stream';
})(MIME || (MIME = {}));
/**
 * A namespace for file constructs.
 */
export var FILE;
(function (FILE) {
    /**
     * Build-time configured file types.
     */
    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');
    /**
     * Get a mimetype (or fallback).
     */
    function getType(ext, defaultType = null) {
        ext = ext.toLowerCase();
        for (const fileType of Object.values(TYPES)) {
            for (const fileExt of fileType.extensions || []) {
                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {
                    return fileType.mimeTypes[0];
                }
            }
        }
        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;
    }
    FILE.getType = getType;
    /**
     * Determine whether the given extension matches a given fileFormat.
     */
    function hasFormat(ext, fileFormat) {
        ext = ext.toLowerCase();
        for (const fileType of Object.values(TYPES)) {
            if (fileType.fileFormat !== fileFormat) {
                continue;
            }
            for (const fileExt of fileType.extensions || []) {
                if (fileExt === ext) {
                    return true;
                }
            }
        }
        return false;
    }
    FILE.hasFormat = hasFormat;
})(FILE || (FILE = {}));
/**
 * The token for the BroadcastChannel broadcaster.
 */
export const IBroadcastChannelWrapper = new Token('@jupyterlite/contents:IBroadcastChannelWrapper');
//# sourceMappingURL=tokens.js.map