import { Contents } from '@jupyterlab/services';
import { FS, ERRNO_CODES, PATH, IEmscriptenStream, IEmscriptenStreamOps, IEmscriptenNodeOps, IEmscriptenFSNode, IStats } from './emscripten';
export declare const DRIVE_SEPARATOR = ":";
export declare const DRIVE_API_PATH = "/api/drive.v1";
export declare const BLOCK_SIZE = 4096;
export type TDriveMethod = 'readdir' | 'rmdir' | 'rename' | 'getmode' | 'lookup' | 'mknod' | 'getattr' | 'get' | 'put';
/**
 * Type of the data argument for the drive request, based on the request name
 */
export type TDriveData = {
    rename: {
        /**
         * The new path for the file
         */
        newPath: string;
    };
    mknod: {
        /**
         * The mode of the file to create
         */
        mode: number;
    };
    put: {
        /**
         * The file content to write
         */
        data: any;
        /**
         * The file content format
         */
        format: Contents.FileFormat;
    };
};
/**
 * Drive request
 */
export type TDriveRequest<T extends TDriveMethod> = {
    /**
     * The method of the request (rmdir, readdir etc)
     */
    method: T;
    /**
     * The expected receiver of the request
     */
    receiver?: 'broadcast.ts';
    /**
     * The path to the file/directory for which the request was sent
     */
    path: string;
} & (T extends keyof TDriveData ? {
    data: TDriveData[T];
} : object);
type TDriveResponses = {
    readdir: string[];
    rmdir: null;
    rename: null;
    getmode: number;
    lookup: DriveFS.ILookup;
    mknod: null;
    getattr: IStats;
    get: {
        /**
         * The returned file content
         */
        content: any;
        /**
         * The content format
         */
        format: Contents.FileFormat;
    } | undefined;
    put: null;
};
/**
 * Drive response
 */
export type TDriveResponse<T extends TDriveMethod> = TDriveResponses[T];
/** Implementation-specifc extension of an open stream, adding the file. */
export interface IDriveStream extends IEmscriptenStream {
    file?: DriveFS.IFile;
}
export declare class DriveFSEmscriptenStreamOps implements IEmscriptenStreamOps {
    private fs;
    constructor(fs: DriveFS);
    open(stream: IDriveStream): void;
    close(stream: IDriveStream): void;
    read(stream: IDriveStream, buffer: Uint8Array, offset: number, length: number, position: number): number;
    write(stream: IDriveStream, buffer: Uint8Array, offset: number, length: number, position: number): number;
    llseek(stream: IDriveStream, offset: number, whence: number): number;
}
export declare class DriveFSEmscriptenNodeOps implements IEmscriptenNodeOps {
    private fs;
    constructor(fs: DriveFS);
    protected node(nodeOrStream: IEmscriptenFSNode | IEmscriptenStream): IEmscriptenFSNode;
    getattr(value: IEmscriptenFSNode | IEmscriptenStream): IStats;
    setattr(value: IEmscriptenFSNode | IEmscriptenStream, attr: IStats): void;
    lookup(parent: IEmscriptenFSNode | IEmscriptenStream, name: string): IEmscriptenFSNode;
    mknod(parent: IEmscriptenFSNode | IEmscriptenStream, name: string, mode: number, dev: number): IEmscriptenFSNode;
    rename(value: IEmscriptenFSNode | IEmscriptenStream, newDir: IEmscriptenFSNode | IEmscriptenStream, newName: string): void;
    unlink(parent: IEmscriptenFSNode | IEmscriptenStream, name: string): void;
    rmdir(parent: IEmscriptenFSNode | IEmscriptenStream, name: string): void;
    readdir(value: IEmscriptenFSNode | IEmscriptenStream): string[];
    symlink(parent: IEmscriptenFSNode | IEmscriptenStream, newName: string, oldPath: string): void;
    readlink(node: IEmscriptenFSNode | IEmscriptenStream): string;
}
/**
 * ContentsAPI base class
 */
export declare abstract class ContentsAPI {
    constructor(driveName: string, mountpoint: string, FS: FS, ERRNO_CODES: ERRNO_CODES);
    lookup(path: string): DriveFS.ILookup;
    getmode(path: string): number;
    mknod(path: string, mode: number): null;
    rename(oldPath: string, newPath: string): null;
    readdir(path: string): string[];
    rmdir(path: string): null;
    get(path: string): DriveFS.IFile;
    put(path: string, value: DriveFS.IFile): null;
    getattr(path: string): IStats;
    /**
     * Normalize a Path by making it compliant for the content manager
     *
     * @param path: the path relatively to the Emscripten drive
     */
    normalizePath(path: string): string;
    abstract request<T extends TDriveMethod>(data: TDriveRequest<T>): TDriveResponse<T>;
    private _driveName;
    private _mountpoint;
    protected FS: FS;
    protected ERRNO_CODES: ERRNO_CODES;
}
/**
 * An Emscripten-compatible synchronous Contents API using the service worker.
 */
export declare class ServiceWorkerContentsAPI extends ContentsAPI {
    constructor(baseUrl: string, driveName: string, mountpoint: string, FS: FS, ERRNO_CODES: ERRNO_CODES);
    request<T extends TDriveMethod>(data: TDriveRequest<T>): TDriveResponse<T>;
    /**
     * Get the api/drive endpoint
     */
    get endpoint(): string;
    private _baseUrl;
}
export declare class DriveFS {
    FS: FS;
    API: ContentsAPI;
    PATH: PATH;
    ERRNO_CODES: ERRNO_CODES;
    driveName: string;
    constructor(options: DriveFS.IOptions);
    node_ops: IEmscriptenNodeOps;
    stream_ops: IEmscriptenStreamOps;
    /**
     * Create the ContentsAPI.
     *
     * This is supposed to be overwritten if needed.
     */
    createAPI(options: DriveFS.IOptions): ContentsAPI;
    mount(mount: any): IEmscriptenFSNode;
    createNode(parent: IEmscriptenFSNode | null, name: string, mode: number, dev: number): IEmscriptenFSNode;
    getMode(path: string): number;
    realPath(node: IEmscriptenFSNode): string;
}
/**
 * A namespace for DriveFS configurations, etc.
 */
export declare namespace DriveFS {
    /**
     * A file representation;
     */
    interface IFile {
        data: Uint8Array;
        format: 'json' | 'text' | 'base64';
    }
    /**
     * The response to a lookup request;
     */
    interface ILookup {
        ok: boolean;
        mode?: number;
    }
    /**
     * Initialization options for a drive;
     */
    interface IOptions {
        FS: FS;
        PATH: PATH;
        ERRNO_CODES: ERRNO_CODES;
        baseUrl: string;
        driveName: string;
        mountpoint: string;
    }
}
export {};
