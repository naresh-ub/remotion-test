import { PageConfig, URLExt } from '@jupyterlab/coreutils';
import { PromiseDelegate } from '@lumino/coreutils';
import * as json5 from 'json5';
/**
 * The name of the local storage.
 */
const DEFAULT_STORAGE_NAME = 'JupyterLite Storage';
/**
 * A class to handle requests to /api/settings
 */
export class Settings {
    constructor(options) {
        this._storageName = DEFAULT_STORAGE_NAME;
        this._storageDrivers = null;
        this._localforage = options.localforage;
        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;
        this._storageDrivers = options.storageDrivers || null;
        this._ready = new PromiseDelegate();
    }
    /**
     * A promise that resolves when the settings storage is fully initialized
     */
    get ready() {
        return this._ready.promise;
    }
    /**
     * A lazy reference to initialized storage
     */
    get storage() {
        return this.ready.then(() => this._storage);
    }
    /**
     * Finish any initialization after server has started and all extensions are applied.
     */
    async initialize() {
        await this.initStorage();
        this._ready.resolve(void 0);
    }
    /**
     * Prepare the storage
     */
    async initStorage() {
        this._storage = this.defaultSettingsStorage();
    }
    /**
     * Get default options for localForage instances
     */
    get defaultStorageOptions() {
        var _a;
        const driver = ((_a = this._storageDrivers) === null || _a === void 0 ? void 0 : _a.length) ? this._storageDrivers : null;
        return {
            version: 1,
            name: this._storageName,
            ...(driver ? { driver } : {}),
        };
    }
    /**
     * Create a settings store.
     */
    defaultSettingsStorage() {
        return this._localforage.createInstance({
            description: 'Offline Storage for Settings',
            storeName: 'settings',
            ...this.defaultStorageOptions,
        });
    }
    /**
     * Get settings by plugin id
     *
     * @param pluginId the id of the plugin
     *
     */
    async get(pluginId) {
        const all = await this.getAll();
        const settings = all.settings;
        const setting = settings.find((setting) => {
            return setting.id === pluginId;
        });
        return setting;
    }
    /**
     * Get all the settings
     */
    async getAll() {
        const allCore = await this._getAll('all.json');
        let allFederated = [];
        try {
            allFederated = await this._getAll('all_federated.json');
        }
        catch {
            // handle the case where there is no federated extension
        }
        // JupyterLab 4 expects all settings to be returned in one go
        // so append the settings from federated plugins to the core ones
        const all = allCore.concat(allFederated);
        // return existing user settings if they exist
        const storage = await this.storage;
        const settings = await Promise.all(all.map(async (plugin) => {
            var _a;
            const { id } = plugin;
            const raw = (_a = (await storage.getItem(id))) !== null && _a !== void 0 ? _a : plugin.raw;
            return {
                ...Private.override(plugin),
                raw,
                settings: json5.parse(raw),
            };
        }));
        return { settings };
    }
    /**
     * Save settings for a given plugin id
     *
     * @param pluginId The id of the plugin
     * @param raw The raw settings
     *
     */
    async save(pluginId, raw) {
        await (await this.storage).setItem(pluginId, raw);
    }
    /**
     * Get all the settings for core or federated plugins
     */
    async _getAll(file) {
        var _a;
        const settingsUrl = (_a = PageConfig.getOption('settingsUrl')) !== null && _a !== void 0 ? _a : '/';
        const all = (await (await fetch(URLExt.join(settingsUrl, file))).json());
        return all;
    }
}
/**
 * A namespace for private data
 */
var Private;
(function (Private) {
    const _overrides = JSON.parse(PageConfig.getOption('settingsOverrides') || '{}');
    /**
     * Override the defaults of the schema with ones from PageConfig
     *
     * @see https://github.com/jupyterlab/jupyterlab_server/blob/v2.5.2/jupyterlab_server/settings_handler.py#L216-L227
     */
    function override(plugin) {
        if (_overrides[plugin.id]) {
            if (!plugin.schema.properties) {
                // probably malformed, or only provides keyboard shortcuts, etc.
                plugin.schema.properties = {};
            }
            for (const [prop, propDefault] of Object.entries(_overrides[plugin.id] || {})) {
                plugin.schema.properties[prop].default = propDefault;
            }
        }
        return plugin;
    }
    Private.override = override;
})(Private || (Private = {}));
//# sourceMappingURL=settings.js.map