"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMediaBuffering = void 0;
const react_1 = require("react");
const log_1 = require("./log");
const use_buffer_state_1 = require("./use-buffer-state");
const useMediaBuffering = ({ element, shouldBuffer, isPremounting, logLevel, }) => {
    const buffer = (0, use_buffer_state_1.useBufferState)();
    const [isBuffering, setIsBuffering] = (0, react_1.useState)(false);
    // Buffer state based on `waiting` and `canplay`
    (0, react_1.useEffect)(() => {
        let cleanupFns = [];
        const { current } = element;
        if (!current) {
            return;
        }
        if (!shouldBuffer) {
            return;
        }
        if (isPremounting) {
            // Needed by iOS Safari which will not load by default
            // and therefore not fire the canplay event.
            // Be cautious about using `current.load()` as it will
            // reset if a video is already playing.
            // Therefore only calling it after checking if the video
            // has no future data.
            // Breaks on Firefox though: https://github.com/remotion-dev/remotion/issues/3915
            if (current.readyState < current.HAVE_FUTURE_DATA) {
                if (!navigator.userAgent.includes('Firefox/')) {
                    log_1.Log.trace(logLevel, `[load] Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox. Element is premounted`);
                    current.load();
                }
            }
            return;
        }
        const cleanup = (reason) => {
            cleanupFns.forEach((fn) => fn(reason));
            cleanupFns = [];
            setIsBuffering(false);
        };
        const blockMedia = (reason) => {
            setIsBuffering(true);
            log_1.Log.trace(logLevel, `[buffer] buffering ${current.src}. reason = ${reason}`);
            const { unblock } = buffer.delayPlayback();
            const onCanPlay = () => {
                cleanup('"canplay" was fired');
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                init();
            };
            const onError = () => {
                cleanup('"error" event was occurred');
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                init();
            };
            current.addEventListener('canplay', onCanPlay, {
                once: true,
            });
            cleanupFns.push(() => {
                current.removeEventListener('canplay', onCanPlay);
            });
            current.addEventListener('error', onError, {
                once: true,
            });
            cleanupFns.push(() => {
                current.removeEventListener('error', onError);
            });
            cleanupFns.push((cleanupReason) => {
                log_1.Log.trace(logLevel, `unblocking ${current.src} from buffer. reason = ${cleanupReason}`);
                unblock();
            });
        };
        const init = () => {
            if (current.readyState < current.HAVE_FUTURE_DATA) {
                blockMedia(`readyState is ${current.readyState}, which is less than HAVE_FUTURE_DATA`);
                // Needed by iOS Safari which will not load by default
                // and therefore not fire the canplay event.
                // Be cautious about using `current.load()` as it will
                // reset if a video is already playing.
                // Therefore only calling it after checking if the video
                // has no future data.
                // Breaks on Firefox though: https://github.com/remotion-dev/remotion/issues/3915
                if (!navigator.userAgent.includes('Firefox/')) {
                    log_1.Log.trace(logLevel, `[load] Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox.`);
                    current.load();
                }
            }
            else {
                const onWaiting = () => {
                    blockMedia('"waiting" event was fired');
                };
                current.addEventListener('waiting', onWaiting);
                cleanupFns.push(() => {
                    current.removeEventListener('waiting', onWaiting);
                });
            }
        };
        init();
        return () => {
            cleanup('element was unmounted or prop changed');
        };
    }, [buffer, element, isPremounting, logLevel, shouldBuffer]);
    return isBuffering;
};
exports.useMediaBuffering = useMediaBuffering;
