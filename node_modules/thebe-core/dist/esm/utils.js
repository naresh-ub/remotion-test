import { __rest } from "tslib";
import { customAlphabet } from 'nanoid';
import { WIDGET_MIMETYPE } from './manager';
const nanoid = customAlphabet('1234567890abcdef', 8);
/**
 * Creates a compact random id for use in runtime objects
 *
 * @returns string
 */
export function shortId() {
    return nanoid();
}
export function ensureString(maybeString) {
    if (Array.isArray(maybeString))
        return maybeString.join('\n');
    return maybeString;
}
export function isMimeBundle({ output_type }) {
    return output_type === 'display_data' || output_type === 'execute_result';
}
export function placeholder(plainText) {
    return `
<div class="thebe-ipywidgets-placeholder">
  <div class="thebe-ipywidgets-placeholder-image"></div>
  <div class="thebe-ipywidgets-placeholder-message"><code>ipywidgets</code> - a Jupyter kernel connection is required to fully display this output.</div>
  ${plainText && `<pre>${plainText}</pre>`}
</div>
`;
}
export function stripWidgets(outputs, hideWidgets = true, placeholderFn = placeholder) {
    return outputs.map((output) => {
        if (!isMimeBundle(output))
            return output;
        const _a = output.data, _b = WIDGET_MIMETYPE, widgets = _a[_b], others = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
        if (!widgets)
            return output;
        let data = output.data;
        if (hideWidgets)
            data = Object.assign({}, others);
        if (placeholderFn && !('text/html' in data))
            // if there is not already an html bundle, add a placeholder to hide the plain/text field
            data['text/html'] = placeholderFn(ensureString(data['text/plain']));
        const stripped = Object.assign(Object.assign({}, output), { data });
        return stripped;
    });
}
//# sourceMappingURL=utils.js.map