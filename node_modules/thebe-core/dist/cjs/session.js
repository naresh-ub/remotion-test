"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = require("./events");
const manager_1 = require("./manager");
const emitter_1 = require("./emitter");
class ThebeSession {
    constructor(server, connection, rendermime) {
        var _a;
        this.server = server;
        this.connection = connection;
        this.events = new emitter_1.EventEmitter(this.connection.id, server.config, events_1.EventSubject.session, this);
        if (this.connection.kernel == null)
            throw Error('ThebeSession - kernel is null');
        this.manager = new manager_1.ThebeManager(this.connection.kernel, rendermime);
        this.connection.statusChanged.connect((_, s) => {
            // 'unknown' | 'starting' | 'idle' | 'busy' | 'terminating' | 'restarting' | 'autorestarting' | 'dead'
            let status;
            switch (s) {
                case 'starting':
                case 'restarting':
                case 'autorestarting':
                    status = events_1.SessionStatusEvent.starting;
                    break;
                case 'idle':
                case 'busy':
                    status = events_1.SessionStatusEvent.ready;
                    break;
                case 'terminating':
                case 'dead':
                default:
                    status = events_1.SessionStatusEvent.shutdown;
                    break;
            }
            this.events.triggerStatus({
                status,
                message: `kernel ${this.connection.name} status changed to ${status}[${s}]`,
            });
            if (s === 'dead') {
                this.events.triggerError({
                    status: events_1.ErrorStatusEvent.session,
                    message: `kernel ${this.connection.name} is dead`,
                });
                this.dispose();
            }
        });
        this.connection.disposed.connect(() => {
            this.events.triggerStatus({
                status: events_1.SessionStatusEvent.shutdown,
                message: `kernel ${this.connection.name} disposed`,
            });
        });
        this.events.triggerStatus({
            status: events_1.SessionStatusEvent.ready,
            message: `ThebeSession created, kernel '${(_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.name}' available`,
        });
    }
    get id() {
        return this.connection.id;
    }
    get kernel() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.kernel;
    }
    get path() {
        return this.connection.path;
    }
    get name() {
        return this.connection.name;
    }
    restart() {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            console.debug(`requesting restart for kernel ${this.id}`);
            const p = (_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.restart();
            this.events.triggerStatus({
                status: events_1.SessionStatusEvent.starting,
                message: `Kernel restart requested`,
            });
            yield p;
            this.events.triggerStatus({
                status: events_1.SessionStatusEvent.ready,
                message: `session restarted, kernel '${(_b = this.connection.kernel) === null || _b === void 0 ? void 0 : _b.name}' available`,
            });
        });
    }
    shutdown() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.connection.isDisposed)
                return;
            yield this.connection.shutdown();
            this.events.triggerStatus({
                status: events_1.SessionStatusEvent.shutdown,
                message: `session ${this.name}`,
            });
            this.dispose();
        });
    }
    dispose() {
        if (!this.connection.isDisposed)
            this.connection.dispose();
    }
}
exports.default = ThebeSession;
//# sourceMappingURL=session.js.map